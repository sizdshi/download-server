#### 下载进程实现细节

##### 1.HTTP下载的原理

1. 本质上是发起一个GET的HTTP请求，默认情况是一个任务完成数据下载
2. 构造一个普通的Socket请求去发送HTTP请求，和读取解析HTTP请求(可以用第三方库，也可以自己简单构造)

##### 2.如何实现分片下载

在发起的GET请求中设置Range字段，比如Range:bytes=100-200 就可以要求从服务器上访问100-200 共100个字节的内容

##### 3.分片下载的流程

1. 因为下载之前不清楚文件大小，所以第一次下载要通过一个普通的GET请求，获取完整的文件大小，获得Response之后，得到完整的文件大小;同时这个请求不读取任何body的内容，也就是只读取了Response的header信息，获取关键的Content-Length字段。
2. 实现下载服务的几个关键技术细节
3. 获得大小之后，计算每次的分配大小，分片的算法可以按照最小32KB，最大10MB的方案进行，按照文件大小，超过10MB以下的按照32KB,10MB到100MB的按照1MB，超过100MB的按照10MB进行分片，计算出所有的分片
4. 计算出分片之后，可以安排下载任务根据分片构造对应Range的请求

##### 4.分片下载如何存储数据

a.获得文件大小之后，需要在下载目录中创建一个临时文件，这个文件的大小就是目标文件的完整大小，通过:

1. 创建一个文件.
2. seek到文件大小的位置
3. 保持文件 就可以生产一个不占空间的文件

b.每个分片下载完成之后，存储到分片的起始位置中，这个过程，因为文件句柄只有一个，需要加锁后进行seek，保证存储位置的准确性

c.所有的分片下载完成之后，文件就下载完成。

##### 5.如何实现已下载的数据重启下载进程不需要重复下载

1. 每个下载任务有个任务记分板文件，每下载完成一个分配，就将分片的索引写入到文件中
2. 当下载任务启动的时候，读取这个任务完成记分板，跳过已下载的分片
3. 记分板文件可以是文本格式也就是每个分片是一个可视化的数字，每个分片一行;也C.可以是二进制的，每个分片占8个字节，根据你们的喜好来即可

##### 6.如何实现多线程的分配调度

1. 每个任务有个一个任务线程+一组下载线程池，下载的进程去获取文件大小以及分配a.任务给线程池
2. 每个下载任务有个下载线程池，每个线程构造带Range的HTTP请求，下载内容后存储到文件中
3. 下载线程是阻塞的请求网络

##### 7.如何实现数据库任务状态变化调度到任务进程

a.任务进程启动后，主线程轮训数据库的状态(每隔200毫秒)

b.根据数据库中的任务状态，对比下载进行中的任务状态

1. 如果数据库状态是暂停，查找进行中的任务暂停任务
2. 如果数据库有运行，但是任务中没有，就创建任务，反之关闭任务

c.如何实现任务的关闭，通过关闭每个任务的任务线程实现任务的关闭

##### 8.如何实现限速

1. 每个任务有个限速令牌桶/秒，每读取数据之后，就消费对应的令牌数据，如果没有可读的数据就阻赛即可
2. 任务的任务线程根据线程池的完成情况，将下载速度更新到数据库中

##### 9.下一步优化重点:

a.数据库轮询

1. 将轮训数据库改成Redis的Pub/Sub,API服务修改数据库状态之后，发布到Redis中
2. 下载程序还是需要定期去轮询数据库，避免出现redis重启之后，丢失状态的情况

b.将BI0的线程池改成全局的NIO模式，整个下载进程就需要4-8个下载线程，完成所有任务的调度，并且可以比较优雅实现任务的取消、暂停、限速功能。